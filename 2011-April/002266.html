<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-dev/2011-April/index.html" >
   <LINK REL="made" HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20eLua%20Peripheral%20Function%20Side%20Effects%20%28was%3A%20eLua%0A%20design%20change%20to%20allow%20synchronized%20PWM%20channel%20start%3F%29&In-Reply-To=%3CBANLkTikmJHvBxuNyWaXZEEeTdf0BW%3DxRyw%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002265.html">
   <LINK REL="Next"  HREF="002267.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)</H1>
    <B>James Snyder</B> 
    <A HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20eLua%20Peripheral%20Function%20Side%20Effects%20%28was%3A%20eLua%0A%20design%20change%20to%20allow%20synchronized%20PWM%20channel%20start%3F%29&In-Reply-To=%3CBANLkTikmJHvBxuNyWaXZEEeTdf0BW%3DxRyw%40mail.gmail.com%3E"
       TITLE="[eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)">jbsnyder at fanplastic.org
       </A><BR>
    <I>Fri Apr  8 23:39:52 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002265.html">[eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)
</A></li>
        <LI>Next message: <A HREF="002267.html">[eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2266">[ date ]</a>
              <a href="thread.html#2266">[ thread ]</a>
              <a href="subject.html#2266">[ subject ]</a>
              <a href="author.html#2266">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Fri, Apr 8, 2011 at 9:25 AM, Martin Guy &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">martinwguy at gmail.com</A>&gt; wrote:
&gt;<i> On 8 April 2011 15:16, Bogdan Marinescu &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">bogdan.marinescu at gmail.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> In general, a system that is &quot;easy to use&quot; cannot be powerful and vice
</I>&gt;&gt;&gt;<i> versa.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I make it my mission to prove this wrong :) Which of course I'll never be
</I>&gt;&gt;<i> able to do, as &quot;easy to use&quot; is a fairly subjective matter.
</I>&gt;<i>
</I>&gt;<i> No, it's a decision you have to make when designing a system, and it
</I>&gt;<i> applies to all fields of technology.
</I>&gt;<i>
</I>&gt;<i> If people want to be able to express themselves with precision, they
</I>&gt;<i> need a larger vocabulary, so need to understand more.
</I>&gt;<i> If you understand less, the range of concepts that you can express is smaller.
</I>
However, even with limited vocabulary you can get useful things done
like ask what time is it? or where is the bathroom?  A user should be
able to do that with a short guide rather than a guide + a 500 page
data sheet.

I don't think anyone here is saying this is easy to do, but the goal,
I believe is to have a system that one can easily dive into without
being an expert in the platform and be able to put together
interesting and neat projects where simple tasks are simple, not
overcomplicated.  At the same time, we're not trying to &quot;dumb down&quot;
the system to make it undesirable for power users.  I don't think at
any level we're suggesting taking away functionality.  This is not
Gnome 3 (what are they thinking?!) :-)

&gt;<i>
</I>&gt;<i> The thing to avoid is making a &#160;system that is difficult to use and
</I>&gt;<i> still gives you no power. Think MS-DOS command.com
</I>&gt;<i>
</I>&gt;<i> Computers are the most complex machines ever built, and creating the
</I>&gt;<i> illusion of simplicity is what programming is all about.
</I>
I suppose there are different ways of looking at this, but I see this
a bit differently.  At least for end users it's about hiding most of
the complexity of what makes the machine work so that they can work at
the level of the task they're interested in so that at that level:
simple tasks are simple

Context is very important though. With the appropriate understanding
of current GUI interface metafors and interaction models, the user
doesn't have to know anything about operating system internals to boot
up their machine and play Solitaire or type up a document.  On the
other hand, if they look in the appropriate places and install the
appropriate tools the layers of abstraction are accessible to work at
lower levels if that's desirable.

The same should be the case with eLua, simple tasks, like setting up
PWM should be simple, but one should tell the user when their
intentions have not been met when a command is executed.  I think
return parameters plus performing at or above certain minimums in
terms of performance cover most of this at least for heavy users that
care.  Warning messages might be a nice optional feature for users to
have especially if they're switching between platforms.  If I run code
on LM3S and things run fine, then I switch to AVR32 or STM32 and
suddenly something doesn't work, something like this could be helpful
in debugging.

On another note:  Silent failure is generally a bad idea in
programming.  On the other hand, in embedded systems one generally
doesn't want to throw unhandlable errors unless they're absolutely
necessary since often times there either is no direct user of the
device or the user doesn't have an ability to fix things.  This also
applies to spewing out lots of messages.  However at development time,
this sort of thing can be useful.

&gt;<i> You do this by hiding the immense underlying complexity, which you do
</I>&gt;<i> by making decisions for the users and doing &quot;the right thing&quot; without
</I>&gt;<i> bothering them.
</I>&gt;<i> How successful you are in doing this determines how easy your product
</I>&gt;<i> is to use, and the goal is the same whether you are aiming at
</I>&gt;<i> high-level or low-level users.
</I>&gt;<i> The Linux device drivers are high-complexity because they give wide
</I>&gt;<i> expressive power to their callers, but they still hide everything else
</I>&gt;<i> that is not relevant.
</I>&gt;<i>
</I>&gt;<i> A flood of warning messages exposes complexity instead of hiding it.
</I>&gt;<i> Think of a Windows machine where there is a constant flow of
</I>&gt;<i> distracting boxes popping up with incomprehensible messages in them.
</I>&gt;<i> No user likes that, whether naive or advanced. It confuses the naive
</I>&gt;<i> ones and annoys the advanced ones.
</I>
Except, what we're talking about here is a user issuing a command
like... change the clock for PWM on one channel, and that affects
multiple channels, or the fractional period isn't the percent they
requested, or the clock isn't what they requested.  These aren't
incomprehensible or irrelevant messages about the printer driver
finding that its cache is corrupted and it needs to clear it, it's
directly relevant to the context of what the user just asked asked us
for, and whether this is done through a warning message or return
parameters (I definitely favor AT LEAST doing the latter.. since
otherwise the user has no idea what we've done differently.. since
they're return parameters on the stack if they don't accept them, then
we just wasted a few compute cycles putting them on the stack, but
that's all).

I don't think anyone is suggesting that this would be used in a manner
where it should always be dumping these out. It should maybe be off by
default or something similar?  Or as suggested it could be handled
similarly to stdout &amp; stderr where it really is a secondary stream
that can either be merged in or split out.

Actually, as I think about this, I think that warnings like this
should probably be off by default, or maybe should only appear if the
user explicitly asks to listen to stderr output in some way.

&gt;<i>
</I>&gt;&gt;<i> the warnings themselves shouldn't have any influence on
</I>&gt;&gt;<i> the actual functionality.
</I>&gt;<i>
</I>&gt;<i> Printing an error message IS a change in functionality.
</I>&gt;<i> If an application changes the duty cycle once per cycle (like the
</I>&gt;<i> crude DAC example), the flood of error messages to print on the serisl
</I>&gt;<i> port will slow the system to a crawl.
</I>&gt;<i> If they are controlling some device on the serial port, a warning
</I>&gt;<i> message will come out in the middle of their protocol.
</I>&gt;<i> At present, a running eLua program never writes anything to the UART
</I>&gt;<i> unless you ask it to.
</I>
So, what's the problem if it isn't enabled by default?  This could be
akin to enabling a debug mode.

Also, these aren't errors.  Actual failures or errors should be
handled differently, these are warnings.



&gt;<i>
</I>&gt;&gt;<i> An observer never modifies the state or functionality of the system it
</I>&gt;&gt;<i> observes
</I>&gt;<i>
</I>&gt;<i> An observer ALWAYS modifies the system it observes.
</I>&gt;<i> Unobtrusive observation, even though it is one of the dogmas of naive
</I>&gt;<i> scientists, is impossible. Even serious physicists have now woken up
</I>&gt;<i> to this.
</I>&gt;<i> It's one of the fallacies of scientific method (the other one is that
</I>&gt;<i> you can recreate the same initial state to repeat the same
</I>&gt;<i> experiment).
</I>
Yep, Bogdan, I think you might have just made Heisenberg turn in his grave :-)

That said.. there actually is one place where one can repeatably run
experiments: in mathematics or computation (provided if you're using
pseudorandom number sources and if you are you seed them consistently)
:<i>-)  We'd really be in trouble if we didn't have repeatable execution
</I>of code on computers (barring cosmic rays, power fluctuations, EMI or
other infrequent interactions with the physical world that manage flip
one or more bits).

&gt;<i>
</I>&gt;&gt;&gt;<i> Linux device drivers are a very different world from a programming
</I>&gt;&gt;&gt;<i> system for beginners, so the policy there (of not enforcing one way of
</I>&gt;&gt;&gt;<i> driving a peripheral, but of having a complex programmer interface
</I>&gt;&gt;&gt;<i> that allows the caller to set the device up with as much precision and
</I>&gt;&gt;&gt;<i> flexibility as possible) is made according to the world of Linux
</I>&gt;&gt;&gt;<i> device drivers.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Sure. It's a good generic principle though and I'm trying to follow it as
</I>&gt;&gt;<i> much as I can.
</I>&gt;<i>
</I>&gt;<i> Don't do that if you want your system to be easy to use.
</I>&gt;<i> An expressive interface is complex, and a complex interface is more
</I>&gt;<i> difficult to use.
</I>&gt;<i> A simple interface is easy to use, but a simple interface doesn't let
</I>&gt;<i> you do much.
</I>&gt;<i> Choosing the right level of complexity/expressiveness in an interface
</I>&gt;<i> is an important choice, but it is still a choice. If you don't make
</I>&gt;<i> that choice consciously, the simple interface will grow lots of extra
</I>&gt;<i> methods to perform advanced tasks... which is what is happening to
</I>&gt;<i> eLua.
</I>
I agree with the last part about choosing complexity/expressiveness.
However, to go back to the language example here: growing some extra
methods, if needed, can be just like learning more of a language to
become more expressive.  The original model matters in terms of making
a choice for initial simplicity or complexity, but in the end if with
something that enables both simple and complex behavior I don't see a
huge problem with growing some extra functions to perform more
advanced tasks.  We haven't really grown the basic individual
peripheral APIs within themselves much after initial implementation so
I don't think we're growing that much in that direction.  Are we
adding additional modules for other advanced tasks that are for other
types of functionality? Yes, as well, but many of these have been
planned features:
<A HREF="http://www.eluaproject.net/en_status.html#roadmap">http://www.eluaproject.net/en_status.html#roadmap</A>

Additionally, much of this is intended to be modular so that it's not
essential to have or use all of it.

I think where one runs into trouble is when either there are needless
tools that just add weight to the system and maintenance thereof.
Addition of features carries quite a bit of weight not only because of
bloat, but because it can be difficult to take them back later :-)

This is not to say that I don't understand your point... even if you
end up with complex systems in both cases, the one designed to be
complex from the outset could be argued to be &quot;cleaner&quot; in some
fashion than the one that started more simply and grew organically.
That said.. I'm having a tough time thinking of great examples of this
working out, most things that started out intending to be complex just
ended up being a mess anyways (ACPI, I'm looking at you...).  Things
that grow organically can turn into messes (bloatware), but they don't
have to.

&gt;<i>
</I>&gt;<i> If you try to make it both complex and simple, both powerful and easy
</I>&gt;<i> to use, you are trying to resolve a paradox and are certain not to
</I>&gt;<i> succeed.
</I>&gt;<i> Of course, in the attempt to do the impossible, you may achieve enlightenment :)
</I>
All designs are a tradeoff to some extent.  I think Apple actually
does a pretty good job with this with their target audiences in Mac OS
X (iOS is a different story with different tradeoffs... I somewhat buy
into them, but not entirely).  I've got pretty much all the power and
flexibility of a BSD Unix underneath a nice clean interface.  While
Linux desktop environments still fight with this to some extent, I
really don't have to give a damn about those underpinnings if I don't
want, but I can dig into them if I want.  Also, while the sources for
the GUI layer might not be available, heck, I can even build my own
kernels if I want to:
<A HREF="http://www.opensource.apple.com/source/xnu/xnu-1504.9.37/">http://www.opensource.apple.com/source/xnu/xnu-1504.9.37/</A>

Whether one agrees or not with this example (there are definitely
problems and flaws with Apple as well), the point is that there are
examples of good tradeoffs in design.  While I'm damned sure we're not
near an ideal point, I'd like to make us better if we can do it :-)

&gt;<i>
</I>&gt;<i> &#160; &#160;M
</I>&gt;<i> _______________________________________________
</I>&gt;<i> eLua-dev mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">eLua-dev at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;<i>
</I>


-- 
James Snyder
Biomedical Engineering
Northwestern University
<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">jbsnyder at fanplastic.org</A>
PGP: <A HREF="http://fanplastic.org/key.txt">http://fanplastic.org/key.txt</A>
Phone: (847) 448-0386

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002265.html">[eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)
</A></li>
	<LI>Next message: <A HREF="002267.html">[eLua-dev] eLua Peripheral Function Side Effects (was: eLua design change to allow synchronized PWM channel start?)
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2266">[ date ]</a>
              <a href="thread.html#2266">[ thread ]</a>
              <a href="subject.html#2266">[ subject ]</a>
              <a href="author.html#2266">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-dev">More information about the eLua-dev
mailing list</a><br>
</body></html>
