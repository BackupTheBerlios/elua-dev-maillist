<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [eLua-dev] An alternative program architecture for embedded Lua
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-dev/2010-June/index.html" >
   <LINK REL="made" HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20An%20alternative%20program%20architecture%20for%20embedded%20Lua&In-Reply-To=%3CDB4A007E-64FC-43B7-8191-C1DD36F1B4DD%40gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001455.html">
   <LINK REL="Next"  HREF="001457.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[eLua-dev] An alternative program architecture for embedded Lua</H1>
    <B>Dean Hall</B> 
    <A HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20An%20alternative%20program%20architecture%20for%20embedded%20Lua&In-Reply-To=%3CDB4A007E-64FC-43B7-8191-C1DD36F1B4DD%40gmail.com%3E"
       TITLE="[eLua-dev] An alternative program architecture for embedded Lua">dwhall256 at gmail.com
       </A><BR>
    <I>Mon Jun 21 03:49:34 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001455.html">[eLua-dev] An alternative program architecture for embedded Lua
</A></li>
        <LI>Next message: <A HREF="001457.html">[eLua-dev] An alternative program architecture for embedded Lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1456">[ date ]</a>
              <a href="thread.html#1456">[ thread ]</a>
              <a href="subject.html#1456">[ subject ]</a>
              <a href="author.html#1456">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ned, excellent discussion topic and ideas.  I work on a different vm  
than eLua, but I listen in because of the overlapping topics.  I've  
been trying to find a way to use coroutines as interrupt handlers.   
Coroutines are functions that persist their own state between calls.   
But, you're right, there's always the issue of notifying the &quot;big  
loop&quot; when an interrupt has occurred and the lag between the actual  
event and when the VM is signaled and can respond to the event.

Coroutines would also be a good way to do the cooperative multi- 
tasking and state machines that you referred to.

Thanks for sharing the info about QP, I'll look into that.

!!Dean


On Jun 20, 2010, at 20:04 , Ned Konz wrote:

&gt;<i> Hello folks,
</I>&gt;<i>
</I>&gt;<i> I'd like to introduce myself. I'm new to Lua, but have been doing  
</I>&gt;<i> embedded system work since 1975 (on the MC6800 microprocessor). I'm  
</I>&gt;<i> now using Cortex-M3 processors, and have been thinking once more  
</I>&gt;<i> about the usefulness of a VM on such a chip.
</I>&gt;<i>
</I>&gt;<i> I'd be interested in hearing your thoughts on the subject.
</I>&gt;<i>
</I>&gt;<i> My own interests don't necessarily include a self-hosted language  
</I>&gt;<i> system (though it's nice to have, I don't know how much space the  
</I>&gt;<i> compiler requires); I'd prefer to spend the flash on system  
</I>&gt;<i> capabilities and extended domain-specific vocabularies.
</I>&gt;<i>
</I>&gt;<i> The eLua VM looks attractive as a dynamic runtime engine, though.
</I>&gt;<i>
</I>&gt;<i> However, the runtime architecture that eLua currently uses (which  
</I>&gt;<i> AFAICT is roughly the same as Lua on the desktop) has a several  
</I>&gt;<i> limitations that I'd like to change:
</I>&gt;<i>
</I>&gt;<i> * No way to do interesting work in Lua from interrupt handlers.  
</I>&gt;<i> Unless you want to use the peripherals the way the driver writer had  
</I>&gt;<i> provided for, you're out of luck.
</I>&gt;<i>
</I>&gt;<i> * The Big Loop structure. The (Big Loop) + (interrupt handlers)  
</I>&gt;<i> scheme has proven to be inflexible and a poor match for the mostly  
</I>&gt;<i> event-driven needs of embedded systems, especially where concurrency  
</I>&gt;<i> is required. Existing threading schemes and primitives (especially  
</I>&gt;<i> semaphores!) are difficult to write reliable code with.
</I>&gt;<i>
</I>&gt;<i> A demonstration of the difficulties of this structure can be seen  
</I>&gt;<i> with the uIP demo code; uIP generates event notifications via  
</I>&gt;<i> callbacks, but the eLua HTTP server application is itself blocking  
</I>&gt;<i> in a Big Loop. So the &quot;impedance mismatch&quot; between the lightweight  
</I>&gt;<i> event notifications from uIP and the blocking socket interface in  
</I>&gt;<i> the server requires extra code and would be hard to multi-thread.
</I>&gt;<i>
</I>&gt;<i> What I'd like to do instead is to implement a system using the eLua  
</I>&gt;<i> VM that does this:
</I>&gt;<i>
</I>&gt;<i> * Allows for eLua peripheral control at a level equivalent to that  
</I>&gt;<i> currently done in C code. Once you get past the simple configuration  
</I>&gt;<i> of I/O ports, the complexity and richness of existing  
</I>&gt;<i> microcontroller peripherals makes it hard to fully use the  
</I>&gt;<i> capabilities of the chip. For instance, I can set up the STM32F10x  
</I>&gt;<i> peripherals so that the timer's input capture event triggers a DMA  
</I>&gt;<i> from a GPIO port to memory, at the same time that I'm using another  
</I>&gt;<i> DMA channel to transfer bytes from the I2C receive into memory, with  
</I>&gt;<i> interrupts at the beginning of each I2C transfer. It would be hard  
</I>&gt;<i> if not impossible to do that in eLua the way it stands now (I think;  
</I>&gt;<i> I'd love to hear that this would be possible to do).
</I>&gt;<i>
</I>&gt;<i> * Allows eLua programs to be structured as one or more hierarchical  
</I>&gt;<i> state machines, each with its own runtime context and event queue.
</I>&gt;<i>
</I>&gt;<i> * Responds to interrupts by packaging up the minimal context (at  
</I>&gt;<i> least which interrupt occurred, and perhaps which of several  
</I>&gt;<i> interrupt sources caused it) into an event and delivering it to  
</I>&gt;<i> (subscribed or all) state machines.
</I>&gt;<i>
</I>&gt;<i> * Does cooperative multi-tasking by using a run-to-completion  
</I>&gt;<i> scheme: each state machine that is ready to run (i.e. has an event  
</I>&gt;<i> ready to react to) gets its current state's handler routine run with  
</I>&gt;<i> the next event; these are not preempted but rather do their work and  
</I>&gt;<i> return.
</I>&gt;<i>
</I>&gt;<i> It seems to me that this would not require any kind of thread  
</I>&gt;<i> support in eLua itself (as the state machine executive is itself a  
</I>&gt;<i> single-threaded program), and that it would better match the needs  
</I>&gt;<i> of embedded systems.
</I>&gt;<i>
</I>&gt;<i> For a good example of how clean an equivalent embedded HTTP server  
</I>&gt;<i> demo can be (using the lwIP TCP/IP stack, which also uses callbacks  
</I>&gt;<i> like uIP), look at <A HREF="http://www.state-machine.com/lwip/">http://www.state-machine.com/lwip/</A> where Miro  
</I>&gt;<i> Samek has provided an example program that includes lwIP, an HTTP  
</I>&gt;<i> server with SSI and CGI capabilities, and the &quot;Dining Philosopher  
</I>&gt;<i> Problem&quot; demo (which is a multi-threaded simulation).
</I>&gt;<i>
</I>&gt;<i> I have ported the QP architecture (described at <A HREF="http://www.state-machine.com">http://www.state-machine.com</A> 
</I>&gt;<i> ) to Ruby and Squeak Smalltalk, and have used it in C programs in  
</I>&gt;<i> embedded systems; I've found it to be very lightweight and a good  
</I>&gt;<i> way to write embedded programs. I would probably use a very similar  
</I>&gt;<i> scheme for eLua.
</I>&gt;<i>
</I>&gt;<i> What do you think?
</I>&gt;<i>
</I>&gt;<i> Ned Konz
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> eLua-dev mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">eLua-dev at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001455.html">[eLua-dev] An alternative program architecture for embedded Lua
</A></li>
	<LI>Next message: <A HREF="001457.html">[eLua-dev] An alternative program architecture for embedded Lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1456">[ date ]</a>
              <a href="thread.html#1456">[ thread ]</a>
              <a href="subject.html#1456">[ subject ]</a>
              <a href="author.html#1456">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-dev">More information about the eLua-dev
mailing list</a><br>
</body></html>
