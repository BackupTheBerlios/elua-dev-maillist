<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [eLua-dev] What can I do?
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-dev/2010-December/index.html" >
   <LINK REL="made" HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20What%20can%20I%20do%3F&In-Reply-To=%3C001f01cb96d2%246d8e9330%2448abb990%24%40hind%40zen.co.uk%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001778.html">
   <LINK REL="Next"  HREF="001780.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[eLua-dev] What can I do?</H1>
    <B>John Hind</B> 
    <A HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20What%20can%20I%20do%3F&In-Reply-To=%3C001f01cb96d2%246d8e9330%2448abb990%24%40hind%40zen.co.uk%3E"
       TITLE="[eLua-dev] What can I do?">john.hind at zen.co.uk
       </A><BR>
    <I>Wed Dec  8 13:21:23 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="001778.html">[eLua-dev] What can I do?
</A></li>
        <LI>Next message: <A HREF="001780.html">[eLua-dev] What can I do?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1779">[ date ]</a>
              <a href="thread.html#1779">[ thread ]</a>
              <a href="subject.html#1779">[ subject ]</a>
              <a href="author.html#1779">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> -----Original Message-----
</I>&gt;<i> From: <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">elua-dev-bounces at lists.berlios.de</A> [mailto:elua-dev-
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">bounces at lists.berlios.de</A>] On Behalf Of Bogdan Marinescu
</I>&gt;<i> Sent: 08 December 2010 11:11
</I>&gt;<i> 
</I>&gt;<i> &gt; If we are satisfied with coroutine (cooperative) multitasking, I do
</I>&gt;<i> not
</I>&gt;<i> &gt; think any additional threading support would be needed.
</I>&gt;<i> 
</I>&gt;<i> I am generally satisfied with that, but of course this varies a lot
</I>&gt;<i> with different application types.
</I>&gt;<i>
</I>
I'm not really, but when we're measuring RAM in KB I think we have to be!
Even Apple runs into RAM problems with pre-emptive multitasking!

&gt;<i> There is generic interrupt support in eLua now for both C and Lua (in
</I>&gt;<i> trunk, will pe part of version 0.8 which is to be released soon).
</I>
I did spot a brief reference to that in the User Labs WiKi, but could not
find anything more about it - I'll have a poke around in the source code.
I'll not ask you to define &quot;soon&quot; - I've found that can be a dangerous
question to ask open source developers!

&gt;<i> Besides interrupt support, a mechanism for polling different interrupt
</I>&gt;<i> flags can be also implemented (think about a &quot;select&quot;-like call that
</I>&gt;<i> works on interrupt flags instead of file descriptors). This might be
</I>&gt;<i> just what you need in your coroutine. In would block in such a
</I>&gt;<i> &quot;select&quot; call waiting for a number of interrupts, one of them being a
</I>&gt;<i> timer expired interrupt (and it would yield if it receives this). This
</I>&gt;<i> can be extended to support generic events, not only interrupts. I
</I>&gt;<i> wouldn't do this &quot;event layer&quot; in C though, sounds more like a job for
</I>&gt;<i> the Lua side.
</I>&gt;<i>
</I>
I do not think this will work - even if the &quot;select&quot; call is non-blocking,
unless the coroutine yields no more Lua code can execute. We need to arrange
it such that the only code that may block is the scheduler - when it has no
more code ready to run it can block or busy-wait for a new event. The timer
expired call I mentioned in the original message was only an example of
using an enhanced coroutine yield to implement a non-blocking event wait -
it could have been any interrupt event.

Most of what I am suggesting could be done either in C or in Lua, but ISRs
have to be C and there has to be a way for ISR code to set a flag which can
be asynchronously read in Lua, on the fly without blocking. Asynchronous
events must be generated by an ISR (and therefore in C code), though they
would not be limited to the interrupt flags specified by the hardware (for
example in serial comms data can be buffered by an ISR until a specified
packet termination criterion is met and then a flag is set in RAM to trigger
the scheduler to run some Lua code). It might be useful to allow events to
be raised in Lua, but these would necessarily be synchronous events
conceptually equivalent to simple Boolean globals.

- Best regards,
John.



</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001778.html">[eLua-dev] What can I do?
</A></li>
	<LI>Next message: <A HREF="001780.html">[eLua-dev] What can I do?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1779">[ date ]</a>
              <a href="thread.html#1779">[ thread ]</a>
              <a href="subject.html#1779">[ subject ]</a>
              <a href="author.html#1779">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-dev">More information about the eLua-dev
mailing list</a><br>
</body></html>
