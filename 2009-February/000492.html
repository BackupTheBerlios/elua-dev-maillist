<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [eLua-dev] Large ADC Commit
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/elua-dev/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20Large%20ADC%20Commit&In-Reply-To=%3C81fbe47d0902170744u116de500wbc6919cb5423fa7b%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000491.html">
   <LINK REL="Next"  HREF="000499.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[eLua-dev] Large ADC Commit</H1>
    <B>Bogdan Marinescu</B> 
    <A HREF="mailto:elua-dev%40lists.berlios.de?Subject=Re%3A%20%5BeLua-dev%5D%20Large%20ADC%20Commit&In-Reply-To=%3C81fbe47d0902170744u116de500wbc6919cb5423fa7b%40mail.gmail.com%3E"
       TITLE="[eLua-dev] Large ADC Commit">bogdan.marinescu at gmail.com
       </A><BR>
    <I>Tue Feb 17 16:44:32 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000491.html">[eLua-dev] Large ADC Commit
</A></li>
        <LI>Next message: <A HREF="000499.html">[eLua-dev] Large ADC Commit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#492">[ date ]</a>
              <a href="thread.html#492">[ thread ]</a>
              <a href="subject.html#492">[ subject ]</a>
              <a href="author.html#492">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On Tue, Feb 17, 2009 at 5:15 PM, James Snyder &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">jbsnyder at fanplastic.org</A>&gt;wrote:

&gt;<i> I'm not sure, actually. I could try always returning a table whether you're
</I>&gt;<i> getting one value or 100.
</I>&gt;<i>
</I>
Ah, I didn't notive this before. Dado's right, let's keep the result type
consistent. Which means that, for now, let's just make our sample function
accept a table as a parameter and return all its data (be it 1 or 100
samples) in that table.

Best,
Bogdan


&gt;<i> ----- &quot;Dado Sutter&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">dadosutter at gmail.com</A>&gt; wrote:
</I>&gt;<i> &gt; Hello,
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; &gt; On Tue, Feb 17, 2009 at 10:53, James Snyder &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">jbsnyder at fanplastic.org</A>&gt;wrote:
</I>&gt;<i> &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;<i> &gt; ----- &quot;Bogdan Marinescu&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">bogdan.marinescu at gmail.com</A>&gt; wrote:
</I>&gt;&gt;<i> &gt; &gt;.............
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; I suppose one could also pass an existing table to getsamples, and get
</I>&gt;&gt;<i> it returned with the results in it?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; I would also prefer that the functions return the same type on all cases
</I>&gt;<i> (so a table passed as a parameter would do just fine for both issues).
</I>&gt;<i> &gt; Do you think that the small overhead caused by the table manipulation
</I>&gt;<i> (instead of an number) justify the returning of a diferent type (a number)
</I>&gt;<i> for critical speed sampling apps ?
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;&gt;<i> &gt; &gt; &gt; Best,
</I>&gt;&gt;<i> &gt; &gt; Bogdan
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt; Best
</I>&gt;<i> &gt; Dado
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; On Feb 16, 2009, at 11:15 AM, James Snyder wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; Hi -
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Thanks for the comments :-)
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; ----- &quot;Bogdan Marinescu&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">bogdan.marinescu at gmail.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; Hi,
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; I still have to look at the code carefully and figure out what
</I>&gt;&gt;&gt;<i> exactly you did there :), but for now a few simple observations:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; 1. it occured to me that since buf_init already expects a
</I>&gt;&gt;&gt;<i> logarithmic parameter, it probably makes sense to make it expect two
</I>&gt;&gt;&gt;<i> logarithmic parameters, so instead of this:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; int buf_set( unsigned resid, unsigned resnum, u8 logsize, size_t
</I>&gt;&gt;&gt;<i> dsize )
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; we'll have this:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; int buf_set( unsigned resid, unsigned resnum, u8 logsize, size_t *
</I>&gt;&gt;&gt;<i> log*dsize )
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; I was thinking about doing this, I'll make the change.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; 2. Since you did this:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;   pbuf-&gt;logsize = logsize + ( pbuf-&gt;logdsize );
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; in buf_set, you probably need to modify this:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; #define BUF_MOD_INCR( p, m ) p-&gt;m = ( p-&gt;m + ( ( u16 )1 &lt;&lt;
</I>&gt;&gt;&gt;<i> p-&gt;logdsize ) ) &amp; ( ( ( u16 )1 &lt;&lt; ( p-&gt;logsize + p-&gt;logdsize) ) - 1 )
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; (because you add logdsize to logsize once again, and I don't think
</I>&gt;&gt;&gt;<i> this is right).
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Ooops.  That would likely be the cause of some of the random crashes
</I>&gt;&gt;&gt;<i> I was seeing :-)  (currently worked around somewhat)
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; 3. The data size of an ADC is not always 16 bits, so we should add
</I>&gt;&gt;&gt;<i> another (probably also logarithmic) parameter to elua_adc/adc_init_state.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; True..  Are you anticipating use of higher or lower bit depth?  There
</I>&gt;&gt;&gt;<i> are certainly lower and higher ones out there, though I've not seen &gt;16-bit
</I>&gt;&gt;&gt;<i> ones built-in to uCs.  If we want to accomodate larger sizes, the return
</I>&gt;&gt;&gt;<i> types for some things will need adjustment, perhaps by defining a type that
</I>&gt;&gt;&gt;<i> reflects the maximum size that will be returned?  This type would be
</I>&gt;&gt;&gt;<i> selected at compile time depending on the maximum bits-per-sample one might
</I>&gt;&gt;&gt;<i> want to work with?
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Something like:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; #if MAX_ADC_BIT_RESOLUTION &lt;= 8
</I>&gt;&gt;&gt;<i> &gt; &gt; typedef u8 t_adc_data
</I>&gt;&gt;&gt;<i> &gt; &gt; #elif MAX_ADC_BIT_RESOLUTION &lt;= 16
</I>&gt;&gt;&gt;<i> &gt; &gt; typedef u16 t_adc_data
</I>&gt;&gt;&gt;<i> &gt; &gt; #elif MAX_ADC_BIT_RESOLUTION &lt;= 32
</I>&gt;&gt;&gt;<i> &gt; &gt; typedef u32 t_adc_data
</I>&gt;&gt;&gt;<i> &gt; &gt; #else
</I>&gt;&gt;&gt;<i> &gt; &gt; #error &quot;No matching type for MAX_ADC_BIT_RESOLUTION, check your
</I>&gt;&gt;&gt;<i> selected bit depth or add larger type&quot;
</I>&gt;&gt;&gt;<i> &gt; &gt; #endif
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; 4. As for the change you proposed, as I said I still have to figure
</I>&gt;&gt;&gt;<i> out what exactly your code does :), but for now it makes sense. I'll get
</I>&gt;&gt;&gt;<i> back to you with more information. Fortunately we don't really have a
</I>&gt;&gt;&gt;<i> pre-existing paradigm, we just have some proposals, so we can change
</I>&gt;&gt;&gt;<i> everything we don't like.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; OK, sounds good.  The one midly complicated thing to make this
</I>&gt;&gt;&gt;<i> approach work with dynamic buffer sizing is to have buf_set handle
</I>&gt;&gt;&gt;<i> increasing buffer size gracefully.  I think the main case to handle is when
</I>&gt;&gt;&gt;<i> wptr &lt; rptr.  i.e. the write pointer has wrapped around to the beginning of
</I>&gt;&gt;&gt;<i> the buffer, but the read ptr has not.  If one just adds space in this case,
</I>&gt;&gt;&gt;<i> the read pointer will start going into as yet unwritten space thinking it is
</I>&gt;&gt;&gt;<i> picking up valid data.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; One way to handle this would be copying data so that the freshly
</I>&gt;&gt;&gt;<i> resized buffer is coherent again.  Another would be to somehow grow the
</I>&gt;&gt;&gt;<i> buffer in the space between the rptr and the wptr.  This, however, without
</I>&gt;&gt;&gt;<i> moving data around, even if it were possible, would result in fragmentation.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; If I were to just do an implementation without further research it
</I>&gt;&gt;&gt;<i> might look like this:
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; 1. If wptr &gt; rptr, just realloc.
</I>&gt;&gt;&gt;<i> &gt; &gt; 2. If rptr &gt; wptr, move all of the elements between buf (array start
</I>&gt;&gt;&gt;<i> pointer) and wptr to space after the wrapping point of the original,
</I>&gt;&gt;&gt;<i> smaller, buffer.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; If we could also grow the buffer at the starting end, maybe we could
</I>&gt;&gt;&gt;<i> decide whether adding at the start or the end would result in more copying.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; I'm not as concerned about algorithms for downsizing the buffer to
</I>&gt;&gt;&gt;<i> conserve space.  I think instead of dealing with copying in this case, the
</I>&gt;&gt;&gt;<i> downsizing might just be done whenever the buffer runs dry, and if no new
</I>&gt;&gt;&gt;<i> interesting requests are pending, drop down to some reasonable default size.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Any thoughts or ideas would certainly be appreciated.
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; Best,
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; Bogdan
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; On Mon, Feb 16, 2009 at 3:12 AM, James Snyder &lt;
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">jbsnyder at fanplastic.org</A>&gt; wrote:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; Hi -
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; I've dropped in another large ADC commit.  I've mentioned most of
</I>&gt;&gt;&gt;<i> what was done in the commit message, but here's a rundown:
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; - When samples are available from ADC, they're initially copied
</I>&gt;&gt;&gt;<i> into an elua buf.
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; - buf length is adjusted according to number of expected samples
</I>&gt;&gt;&gt;<i> coming in (when burst is requested, buf is resized to accomodate the number
</I>&gt;&gt;&gt;<i> of burst samples, size is dropped back down when single samples are
</I>&gt;&gt;&gt;<i> requested)
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; - if smoothing is enabled, and has no samples, smoothing buffer
</I>&gt;&gt;&gt;<i> (not an elua buf) is filled first to warm up the filter, then samples begin
</I>&gt;&gt;&gt;<i> to accumulate in the main buffer.
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; - a flush function has been added to manually clear out both
</I>&gt;&gt;&gt;<i> smoothing and primary buffers in case one doesn't want old samples or old
</I>&gt;&gt;&gt;<i> smoothing data being used for future measurements
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; Also, I forgot to mention one thing in the commit message:  As
</I>&gt;&gt;&gt;<i> per a discussion with Bogdan, the type checking on buf_write and buf_read
</I>&gt;&gt;&gt;<i> have been pulled out.
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; One adjustment that I'd like to consider before the 0.6 freeze is
</I>&gt;&gt;&gt;<i> to remove the option for blocking and non-blocking as it applies to sample
</I>&gt;&gt;&gt;<i> and burst functions (used to initiate sampling) and to instead make these
</I>&gt;&gt;&gt;<i> always non-blocking, and never have them return any samples (only errors, if
</I>&gt;&gt;&gt;<i> needed).  A separate function, say getsamples would pull in data collected
</I>&gt;&gt;&gt;<i> using either mode.  Right now, if one uses non-blocking mode, samples will
</I>&gt;&gt;&gt;<i> always be returned for the last time you ran sample or burst.  This means
</I>&gt;&gt;&gt;<i> that if you want to get the data already requested, you also have to always
</I>&gt;&gt;&gt;<i> request new samples, even if you don't want them.
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; I should be able to make this change with minimal code changes,
</I>&gt;&gt;&gt;<i> but I haven't done it yet because it changes the pre-existing paradigm, and
</I>&gt;&gt;&gt;<i> I wanted to get these changes in sooner rather than later :-)
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; I think it might just take me another hour or so to get
</I>&gt;&gt;&gt;<i> adjustments along those lines working.  There wouldn't be as long of a delay
</I>&gt;&gt;&gt;<i> as this ADC commit.
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; Suggestions/comments are welcome :-)
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; -jsnyder
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; _______________________________________________
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; Elua-dev mailing list
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; &gt; _______________________________________________ Elua-dev mailing
</I>&gt;&gt;&gt;<i> list <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;&gt;&gt;<i> &gt; _______________________________________________
</I>&gt;&gt;&gt;<i> &gt; &gt; Elua-dev mailing list
</I>&gt;&gt;&gt;<i> &gt; &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;&gt;&gt;<i> &gt; &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i>  &gt; &gt; &gt; &gt; --
</I>&gt;&gt;&gt;<i> James Snyder
</I>&gt;&gt;&gt;<i> Biomedical Engineering
</I>&gt;&gt;&gt;<i> Northwestern University
</I>&gt;&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">jbsnyder at fanplastic.org</A>
</I>&gt;&gt;&gt;<i> <A HREF="http://fanplastic.org/key.txt">http://fanplastic.org/key.txt</A>
</I>&gt;&gt;&gt;<i> ph: (847) 644-2322
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> &gt; &gt; _______________________________________________&gt;
</I>&gt;&gt;&gt;<i> &gt; &gt; Elua-dev mailing list
</I>&gt;&gt;&gt;<i> &gt; &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;&gt;&gt;<i> &gt; &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt; &gt;
</I>&gt;&gt;<i> &gt; &gt; _______________________________________________ Elua-dev mailing list
</I>&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> &gt; _______________________________________________
</I>&gt;&gt;<i> &gt; Elua-dev mailing list
</I>&gt;&gt;<i> &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;&gt;<i> &gt; <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;&gt;<i> &gt;
</I>&gt;&gt;<i> &gt;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; _______________________________________________ Elua-dev mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Elua-dev mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">Elua-dev at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/elua-dev">https://lists.berlios.de/mailman/listinfo/elua-dev</A>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="https://lists.berlios.de/pipermail/elua-dev/attachments/20090217/ef661fd5/attachment.html">https://lists.berlios.de/pipermail/elua-dev/attachments/20090217/ef661fd5/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000491.html">[eLua-dev] Large ADC Commit
</A></li>
	<LI>Next message: <A HREF="000499.html">[eLua-dev] Large ADC Commit
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#492">[ date ]</a>
              <a href="thread.html#492">[ thread ]</a>
              <a href="subject.html#492">[ subject ]</a>
              <a href="author.html#492">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/elua-dev">More information about the eLua-dev
mailing list</a><br>
</body></html>
